<!DOCTYPE html>
<html>
<head>
  <title>Basic Breakout HTML Game</title>
  <meta charset="UTF-8">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: black;
    }
    #instructionArea {
      color: white;
      font-size: 18px;
      text-align: center;
      margin-bottom: 10px;
      z-index: 10;
    }
    #ballCount {
      color: white;
      font-size: 18px;
      margin-bottom: 10px;
      font-family: monospace;
    }
    canvas {
      border: 1px solid lightgrey;
    }
    button {
      margin-top: 10px;
      padding: 10px 20px;
      font-size: 16px;
      color: white;
      background-color: #007BFF;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <div id="instructionArea">Use arrow keys to move the paddle, and press space key to launch a ball. Warning you only have 3 balls in total to get all the bricks and win! The • represents a ball, the * represents the ball you are currently using at the time.</div>
  <div id="ballCount">Balls Left: • • •</div>
  <canvas width="400" height="500" id="game"></canvas>
  <button id="resetButton">Reset Game</button>
  <script>
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');
    const ballCountDisplay = document.getElementById('ballCount');

    const level1 = [
      [],
      [],
      [],
      [],
      [],
      [],
      ['R','R','R','R','R','R','R','R','R','R','R','R','R','R'],
      ['R','R','R','R','R','R','R','R','R','R','R','R','R','R'],
      ['O','O','O','O','O','O','O','O','O','O','O','O','O','O'],
      ['O','O','O','O','O','O','O','O','O','O','O','O','O','O'],
      ['G','G','G','G','G','G','G','G','G','G','G','G','G','G'],
      ['G','G','G','G','G','G','G','G','G','G','G','G','G','G'],
      ['Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y'],
      ['Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y']
    ];

    const colorMap = {
      'R': 'red',
      'O': 'orange',
      'G': 'green',
      'Y': 'yellow'
    };

    const brickGap = 2;
    const brickWidth = 25;
    const brickHeight = 12;
    const wallSize = 12;
    const bricks = [];

    for (let row = 0; row < level1.length; row++) {
      for (let col = 0; col < level1[row].length; col++) {
        const colorCode = level1[row][col];
        if (colorCode) {
          bricks.push({
            x: wallSize + (brickWidth + brickGap) * col,
            y: wallSize + (brickHeight + brickGap) * row,
            color: colorMap[colorCode],
            width: brickWidth,
            height: brickHeight
          });
        }
      }
    }

    const paddle = {
      x: canvas.width / 2 - brickWidth / 2,
      y: 440,
      width: brickWidth,
      height: brickHeight,
      dx: 0
    };

    let balls = [];
    let ballsLeft = 3;
    let ballDisplayState = [0, 0, 0]; // 0 = "•", 1 = "*", 2 = " "
    let allBallsUsed = false;

    function createBall() {
      const dx = Math.random() < 0.5 ? -2 : 2;
      return {
        x: 130,
        y: 260,
        width: 5,
        height: 5,
        speed: 2,
        dx: dx,
        dy: 2,
        blinking: true
      };
    }

    function collides(obj1, obj2) {
      return obj1.x < obj2.x + obj2.width &&
             obj1.x + obj1.width > obj2.x &&
             obj1.y < obj2.y + obj2.height &&
             obj1.y + obj1.height > obj2.y;
    }

    function areAllBallsUsed() {
      return ballDisplayState.every(state => state === 2);
    }

    function updateBallCountDisplay() {
      if (areAllBallsUsed()) {
        ballCountDisplay.textContent = 'No more balls left, refresh the page or click the Reset Game button to play again.';
        return;
      }

      let ballsDisplay = 'Balls Left: ';
      for (let i = 0; i < 3; i++) {
        if (ballDisplayState[i] === 0) {
          ballsDisplay += '• ';
        } else if (ballDisplayState[i] === 1) {
          ballsDisplay += '* ';
        } else {
          ballsDisplay += '  ';
        }
      }
      ballCountDisplay.textContent = ballsDisplay.trim();
    }

    function loop() {
      requestAnimationFrame(loop);
      context.clearRect(0, 0, canvas.width, canvas.height);
      
      paddle.x += paddle.dx;
      
      if (paddle.x < wallSize) paddle.x = wallSize;
      else if (paddle.x + brickWidth > canvas.width - wallSize) paddle.x = canvas.width - wallSize - brickWidth;

      balls.forEach((ball, index) => {
        ball.x += ball.dx;
        ball.y += ball.dy;

        if (ball.x < wallSize) {
          ball.x = wallSize;
          ball.dx *= -1;
        } else if (ball.x + ball.width > canvas.width - wallSize) {
          ball.x = canvas.width - wallSize - ball.width;
          ball.dx *= -1;
        }
        if (ball.y < wallSize) {
          ball.y = wallSize;
          ball.dy *= -1;
        }
        
        if (ball.y > canvas.height) {
          balls.splice(index, 1);
          // Update the display state to show empty space (right to left)
          for (let i = 0; i <= 2; i++) {
            if (ballDisplayState[i] === 1) {
              ballDisplayState[i] = 2; // Change to empty space
              break;
            }
          }
          updateBallCountDisplay();
        }

        if (collides(ball, paddle)) {
          ball.dy *= -1;
          ball.y = paddle.y - ball.height;
        }

        bricks.forEach((brick, i) => {
          if (collides(ball, brick)) {
            bricks.splice(i, 1);
            if (ball.y + ball.height - ball.speed <= brick.y || ball.y >= brick.y + brick.height - ball.speed) {
              ball.dy *= -1;
            } else {
              ball.dx *= -1;
            }

            if (bricks.length === 0) {
              alert("You Win!");
              location.reload();
            }
          }
        });

        context.fillStyle = 'white';
        context.fillRect(ball.x, ball.y, ball.width, ball.height);
      });

      context.fillStyle = 'lightgrey';
      context.fillRect(0, 0, canvas.width, wallSize);
      context.fillRect(0, 0, wallSize, canvas.height);
      context.fillRect(canvas.width - wallSize, 0, wallSize, canvas.height);
      
      bricks.forEach(function(brick) {
        context.fillStyle = brick.color;
        context.fillRect(brick.x, brick.y, brick.width, brick.height);
      });
      
      context.fillStyle = 'cyan';
      context.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    }

    document.addEventListener('keydown', function(e) {
      if (e.which === 37) paddle.dx = -3;
      else if (e.which === 39) paddle.dx = 3;
      else if (e.which === 32 && balls.length === 0 && ballsLeft > 0) {
        const newBall = createBall();
        balls.push(newBall);
        ballsLeft--;
        // Update the display state to show asterisk (right to left)
        for (let i = 2; i >= 0; i--) {
          if (ballDisplayState[i] === 0) {
            ballDisplayState[i] = 1; // Change to asterisk
            break;
          }
        }
        updateBallCountDisplay();
      }
    });

    document.addEventListener('keyup', function(e) {
      if (e.which === 37 || e.which === 39) paddle.dx = 0;
    });

    document.getElementById('resetButton').addEventListener('click', function() {
      location.reload();
    });

    updateBallCountDisplay();
    requestAnimationFrame(loop);
  </script>
</body>
</html>